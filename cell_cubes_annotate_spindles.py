import os
import napari
import random
import numpy as np
from voldist_tools.basictools import wipe_layers, open_with_napari, calculate_label_properties
from skimage.morphology import remove_small_objects
from tifffile import imread

'''
Opens a napari viewer. The key press "n" will open a random cell cube (generated by cell_cubes_create).
If a given segmentation is a spindle, the key press 'q' will open a magicgui widget asking for the label
identity of the spindle. It then measured the properties of all labels in the cell cube (area, major axis
length, minor axis length, label id, distance to cell mask centroid, and label density), annotates the
appropriate label as a spindle, and saves the data as a csv file.
'''
def remove_large_objects(labels_array: np.ndarray, max_size: int) -> np.ndarray:
    ''' 
    Remove all objects in a mask above a specific threshold
    '''
    out = np.copy(labels_array)
    component_sizes = np.bincount(labels_array.ravel()) 
    too_big = component_sizes > max_size
    too_big_mask = too_big[labels_array]
    out[too_big_mask] = 0
    return out
def open_with_napari(file_path: str, viewer_name, view_pi = False) -> None:
    '''
    Open contents of a file with napari
    ---
    Parameters:
    file_path: str the path to the file to open
    ---
    Returns:
    None
    '''
    wipe_layers(viewer_name)
    cell_mask_path = os.path.join(file_path, 'curr_mask_cube.tif')
    tub_path = os.path.join(file_path, 'cubed_tub_dog_th.tif')
    labels_path = os.path.join(file_path, 'thresh_mask.tif')
    pi_path = os.path.join(file_path, 'curr_PI_cube.tif')
    if view_pi:
        viewer_name.add_labels(imread(cell_mask_path), name = 'cell mask', blending='additive', opacity = 0.125)
        viewer_name.add_image(imread(pi_path), name = 'PI', blending='additive')
    else:
        all_labels = imread(labels_path)
        all_labels = remove_small_objects(all_labels, min_size=200)
        all_labels = remove_large_objects(all_labels, max_size=5000)
        
        viewer_name.add_labels(imread(cell_mask_path), name = 'cell mask', blending='additive', opacity = 0.75)
        viewer_name.add_image(imread(tub_path), name = 'tub', blending='additive', visible = False)
        viewer_name.add_image(imread(pi_path), name = 'PI', blending='additive', visible = False)
        viewer_name.add_labels(all_labels, name = 'labels', blending='additive', opacity = 0.75, visible = False)


if __name__ == '__main__':

    main_dir = '/Volumes/bigData/wholeMount_volDist/220712_Fix_Emb_Flvw_Chn1GAP_PI_aTub647_Processed/0_N2V_Denoised/0_Analysis_01/0_data_cubes_TopHat-DoG_mask_otsu'
    main_dir = '/Volumes/bigData/wholeMount_volDist/220712_Fix_Emb_Flvw_Chn1GAP_PI_aTub647_Processed/0_N2V_Denoised/0_Analysis_01/0_data_cubes_TopHat-DoG_mask_otsu'
    save_dir = os.path.join(main_dir, 'label_properties')
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    cube_paths = [] 
    subdirs = [s for s in os.listdir(main_dir) if 'Exp_E06' in s and not s.startswith('.') and not 'label' in s and not 'processed' in s]
    for subdir in subdirs:
        cell_nums = [s for s in os.listdir(os.path.join(main_dir, subdir)) if not s.startswith('.')]
        for cell_num in cell_nums:
            folder_path = os.path.join(main_dir, subdir, cell_num)
            cube_paths.append(folder_path)

    random.shuffle(cube_paths)


    def annotate_spindles(spindle_ID: str, viewer_name):

        all_label_nums, label_props_df = calculate_label_properties(napari_viewer_name = viewer_name)

        # sanity checks up on input:
        try:
            spindle_ID = int(spindle_ID)
        except ValueError:
            print('spindle label number must be an integer')
            return
        if spindle_ID not in np.unique(all_label_nums) and spindle_ID != 0:
            print(f'label {spindle_ID} not found')
            print('please enter 0 if no spindle threshold is detected')
            return
        if spindle_ID == 0:
            spindle_ID = None
            print('No spindle threshold specified. Categorizing all labels as non-spindle.')
        else:
            print(f'calculating properties for spindle {spindle_ID}')

        # categorize labels
        label_props_df['category'] = label_props_df['label'].apply(lambda x: 'spindle' if x == spindle_ID else 'trash')
        # drop the label column and save the df
        label_props_df.drop(columns=['label'], inplace=True)
        label_props_df.to_csv(os.path.join(save_dir, f'{cube_name}.csv'), index=False)
        print(f'saved {cube_name}.csv')
    
    def annotate_spindle_halves(half_IDs: str, viewer_name):
        all_label_nums, label_props_df = calculate_label_properties(napari_viewer_name = viewer_name)

        # sanity checks up on input:
        input_split = half_IDs.split(',')
        if len(input_split) != 2 and not half_IDs == '0':
            print('please enter two label numbers separated by a comma')
            return
        try:
            input_split = [int(i) for i in input_split]
        except ValueError:
            print('please enter two label INTEGERS separated by a comma')
            return
        for id in input_split:
            if id not in all_label_nums and not half_IDs == '0':
                print(f'label {id} not found')
                print('please enter 0 if no spindle threshold is detected')
                return
        if half_IDs == '0':
            half_IDs = None
            print('No spindle threshold specified. Categorizing all labels as non-spindle.')
        else:
            print(f'calculating properties for spindle IDs {half_IDs}')

        # categorize labels
        label_props_df['category'] = label_props_df['label'].apply(lambda x: 'half' if x in input_split else 'trash')
        
        # drop the label column and save the df
        label_props_df.drop(columns=['label'], inplace=True)
        label_props_df.to_csv(os.path.join(save_dir, f'{cube_name}.csv'), index=False)
        print(f'saved {cube_name}.csv')


    viewer = napari.Viewer(title = 'this is the cube viewer')

    @viewer.bind_key('n')
    def next_cube(viewer):
        wipe_layers(viewer)
        # define next_path variable as global
        next_path = cube_paths.pop(0)
        open_with_napari(next_path, viewer)
        global cube_name
        cube_name = "_".join(next_path.rsplit('/', 2)[1:])
        print(f'Now viewing {cube_name}')

    @viewer.bind_key('q')
    def get_input(viewer):
        from magicgui.widgets import request_values
        values = request_values(name=dict(annotation=str, label='spindle label:'))
        if values == None:
            print('please enter a value')
        else:
            annotate_spindles(spindle_ID = values['name'], viewer_name = viewer)

    @viewer.bind_key('p')
    def get_input(viewer):
        from magicgui.widgets import request_values
        values = request_values(name=dict(annotation=str, label='enter the label numbers for the spindle \n halves separated by commas:'))
        if values == None:
            print('please enter a value')
        else:
            annotate_spindle_halves(half_IDs = values['name'], viewer_name = viewer)

    napari.run()








            